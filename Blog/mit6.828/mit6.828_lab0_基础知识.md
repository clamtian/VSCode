# 0.常用指令
这一章节主要记录在整个实验中常用的一些指令，由于实验完成时间跨度比较长，所以专门开辟了一个章节用来记录，省去查找的时间。

1. 运行操作系统
   * `make qume` 
   * `make qemu-nox` 无窗口
   * `make run-x` 运行x程序
   * 
2. 调试操作系统
   * `make qemu-gdb` && `make gdb`
   * `si` 运行一步

3.提交流程
   * `git commit -am "lab3 a"` 先提交
   * `make handin` 上交
   * `make grade` 打分


# 1.汇编知识

## 1.1 寄存器

段寄存器
 
每个处理器有 6 个段寄存器有，CS 代码段，SS 栈段，DS 数据段，ES FS GS 附加数据段，xv6 里只用到了前 4 个段寄存器，FS GS 没有使用。实模式下，段寄存器里面的存放的是段基址，保护模式下，段寄存器里面存放的是段选择子。当然这只是可见部分，段寄存器还有不可见部分作为段描述符的缓存。所以在保护模式下，有了段寄存器之后，地址转换的时候不用每次都要根据段选择子去索引段描述符获取段基址，有缓存的话直接去缓存里面获取即可，加快了地址转换的速度。要访问一个内存段的时候，这个段的段选择子必须加载到某段寄存器，所以一个系统虽然可以定义上千个段，但是当前使用的段最多就只有 6 个。当然这只是单个处理器，每个处理器都有 6 个段寄存器，有各自的 GDT，有各自定义的内存段。

控制寄存器

每个处理器有 5 个控制寄存器，每个寄存器 32 位：CR0、CR1、CR2、CR3和CR4。其中发生缺页异常的时候，CR2 里面就会存放引发缺页的那个地址，CR3存放页目录的地址(物理地址)。

GDTR 寄存器

GDT 是硬件支持的一个数据结构，专门有个寄存器 GDTR 指示 GDT 的起始位置和大小，GDT 的位置信息加载到 GDTR 之后，CPU 才知道 GDT 在哪。

IDTR 寄存器

同 GDT 有个 GDTR 指示 GDT 的位置，IDT 也有个 IDTR 指示 IDT 的位置。IDTR 里存放着 IDT 的地址和界限。

EIP 寄存器

EIP 寄存器用来存储 CPU 要读取指令的地址，CPU 通过 EIP 寄存器读取即将要执行的指令。每次 CPU 执行完相应的汇编指令之后，EIP 寄存器的值就会增加。


## 1.2

esp是栈顶指针寄存器，ebp是栈底指针寄存器。

ESP 指向了当前栈顶在栈段的偏移量，配合 SS 栈段中的栈基址，就可以找到当前栈顶的位置。每次进入一个新的函数，EBP 就用来保存当前函数的栈底。

```javascript
     +--------------------+ <---- EBP 栈底
     |        ...         |     " - 4 
     |      data 3        |     " - 8 
     |      data 2        |     " - 12 
     |      data 1        |     " - 16  <---- ESP 栈顶 
     +--------------------+             
```

## 1.3

指令指针EIP (Instruction Pointer)是存放下次将要执行的指令在代码段的偏移量

ret指令：将栈顶值存入 EIP 寄存器中，实现执行指令的跳转

