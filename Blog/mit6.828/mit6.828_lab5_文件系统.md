
# 1.文件系统

我们将实现的文件系统比大多数“实际”文件系统(包括xv6 UNIX)要简单得多，但是它的功能足够强大，可以提供基本特性:创建、读取、写入和删除按层次目录结构组织的文件。

我们(至少目前)只开发一个单用户操作系统，它提供了足够的保护来捕获bug，但不能保护多个相互怀疑的用户。因此，我们的文件系统不支持UNIX文件所有权或权限的概念。我们的文件系统目前也不像大多数UNIX文件系统那样支持硬链接、符号链接、时间戳或特殊设备文件。

## 1.1 磁盘文件系统结构

大多数UNIX文件系统将可用磁盘空间划分为两种主要区域类型:inode 区域 和 data 区域。UNIX文件系统为文件系统中的每个文件分配一个inode;文件的inode包含关于文件的关键元数据(meta-data)，比如文件类型(常规、目录、符号链接等），权限，文件大小，创建/修改/访问时间，文件数据块信息等，我们运行的ls -l看到的内容，都是存储在inode而不是数据块中的。数据部分通常分为很多数据块，数据块用于存储文件的数据信息以及目录的元数据(目录元数据包括目录下文件的inode，文件名，文件类型等);如果文件系统中的多个目录条目引用该文件的inode，则该文件被称为硬链接的。由于我们的文件系统不支持硬链接，所以我们不需要这种间接级别，因此可以方便地简化:我们的文件系统根本不使用inode，而只是在描述该文件的(唯一的)目录条目中存储文件(或子目录)的所有元数据。

文件和目录在逻辑上都由一系列数据块组成。它可以分散在磁盘上，就像environment的虚拟地址空间的页面可以分散在物理内存中一样。文件系统环境隐藏了块布局的细节，显示了在文件中任意偏移量处读取和写入字节序列的接口。文件系统环境在内部处理对目录的所有修改，作为执行文件创建和删除等操作的一部分。我们的文件系统允许用户环境直接读取目录元数据(例如，使用read)，这意味着用户环境可以自己执行目录扫描操作(例如，实现ls程序)，而不必依赖于对文件系统的额外特殊调用。这种目录扫描方法的缺点(也是大多数现代UNIX变体不支持这种方法的原因)是，它使应用程序依赖于目录元数据的格式，使得在不更改或至少重新编译应用程序的情况下更改文件系统的内部布局非常困难。

## 1.2 磁盘扇区、数据块、超级块

扇区是磁盘的物理属性，通常一个扇区大小为512字节，而数据块则是操作系统使用磁盘的一个逻辑属性，一个块大小通常是扇区的整数倍。UNIX xv6文件系统使用512字节的块大小，与底层磁盘的扇区大小相同。然而，大多数现代文件系统使用更大的块，因为存储空间变得更便宜，而且在更大粒度上管理存储更有效。我们的JOS文件系统将使用4096字节的块大小，方便地匹配处理器的页面大小。

文件系统通常将某些磁盘块保留在磁盘上某个"容易找到"的地方(例如最开始或者最末端)去保存描述整个文件系统属性的元数据，比如block size、disk size、查找root directory所需的任何元数据、最后一次挂载文件系统的时间、最后一次检查文件系统是否出错的时间等等。这些特殊的块就是superblocks。

我们的文件系统将只有一个超级块，它总是在磁盘上的block 1(第二块)。它的布局是由struct Super在`inc/fs.h`中定义的。block 0通常保留用于保存boot loaders和partition tables(分区表)，因此文件系统通常不使用第一个磁盘块。许多常用的文件系统有多个超级块，这些超级块复制到磁盘的多个widely-space(宽间距)区域，因此，如果其中一个超级块损坏了，或者磁盘在该区域出现了错误，仍然可以找到其他超级块，并使用它们访问文件系统。

![avatar](./image/lab5_block.png)

## 1.3 文件元数据

文件系统中描述文件的元数据的布局由`inc/fs.h`中的struct file描述。这个元数据包括文件的名称、大小、类型(常规文件或目录)和指向组成文件的块的指针。如上所述，我们没有inode，所以这个元数据存储在磁盘上的目录条目中。与大多数文件系统不同，为了简单起见，我们将使用这个File structure来表示文件元数据，因为它同时出现在磁盘和内存中。

```javascript
struct File {
	char f_name[MAXNAMELEN];	// filename
	off_t f_size;			// file size in bytes
	uint32_t f_type;		// file type

	// Block pointers.
	// A block is allocated iff its value is != 0.
	uint32_t f_direct[NDIRECT];	// direct blocks
	uint32_t f_indirect;		// indirect block

	// Pad out to 256 bytes; must do arithmetic in case we're compiling
	// fsformat on a 64-bit machine.
	uint8_t f_pad[256 - MAXNAMELEN - 8 - 4*NDIRECT - 4];
} __attribute__((packed));	// required only on some 64-bit machines
```

struct File中的f_direct数组包含存储文件前10个(NDIRECT)块的块号的空间，我们称之为文件的直接块。对于大小高达10*4096B = 40KB的小文件，这意味着所有文件块的块号将直接适合File structure 本身。但是，对于较大的文件，我们需要一个地方来保存文件的其余块号。因此，对于任何大于40KB的文件，我们分配一个额外的磁盘块，称为文件的间接块，以容纳4096/4 = 1024个额外的块号。

因此，我们的文件系统允许文件的大小最多为1034块，即超过4MB一点点。为了支持更大的文件，真正的文件系统通常还支持双间接块和三间接块。

![avatar](./image/lab5_meta-data.png)

## 1.4 文件和目录

文件系统中的File structure既可以表示普通文件，也可以表示目录;这两种类型的“files”由文件结构中的type字段来区分。文件系统以完全相同的方式管理常规文件和目录文件，唯一区别是对常规文件，文件系统并不解析数据块内容，而对于目录，则会将数据内容解析为 struct File 的格式。

我们的文件系统中的superblock含一个File structure(struct Super中的root字段)，它保存文件系统根目录的元数据。这个目录文件的内容是描述文件系统根目录中的文件和目录的File structure序列。根目录中的任何子目录都可能包含更多表示子目录的文件结构，依此类推。

# 2.文件系统实现

本实验我们要完成的功能包括：

* 读取磁盘中的数据块到块缓存以及将块缓存中的数据刷回磁盘。
* 分配数据块。
* 映射文件偏移到磁盘数据块。
* 在IPC接口实现文件的open，read，write，close。

## 2.1 磁盘访问

不同于Linux等系统那样增加一个磁盘驱动并添加相关系统调用实现磁盘访问，JOS的磁盘驱动是用用户级程序实现的，当然还是要对内核做一点修改，以支持文件系统进程(用户级进程)有权限访问磁盘。

在用户空间访问磁盘可以通过轮询的方式实现，而不是使用磁盘中断的方式，因为使用中断的方式会复杂不少。x86处理器使用 EFLAGS 寄存器的 IOPL 位来控制磁盘访问权限(即IN和OUT指令)，用户代码能否访问IO空间就通过该标志来设置。JOS在`i386_init()`中运行了一个用户级的文件系统进程，该进程需要有磁盘访问权限。因此作业1就是在 `env_create` 中对 文件系统进程 这个特殊的运行在用户级的进程设置 IOPL 权限，而其他的用户进程不能设置该权限，根据进程类型设置权限即可。

我们的文件系统将仅限于处理3GB或更小的磁盘。我们保留文件系统environment的地址空间的一个大的、固定的3GB区域，从0x10000000 (DISKMAP)到0xD0000000 (DISKMAP+DISKMAX)，作为磁盘的“内存映射”版本。下面是文件系统环境的虚拟内存空间:[感谢 bysui的图](https://blog.csdn.net/bysui/article/details/51868917)

![avatar](./image/lab5_file-environment.png)

将整个磁盘读取到内存中要花很长时间，所以只有在发生页面错误时，我们才在磁盘映射区域分配页和从磁盘读取相应的块(ide_read函数)。

## 2.2 用户程序页面错误处理流程



## 2.3 用户进程异常栈和常规栈



## 2.4 调用用户页面错误处理函数



## 2.5 写时复制总流程



# 3.抢占式调度和进程间通信

## 3.1 时钟中断


## 3.2 进程间通信



1. https://pdos.csail.mit.edu/6.828/2018/labs/lab5/
2. https://www.jianshu.com/p/e894b3660d75
3. https://github.com/shishujuan/mit6.828-2017/blob/master/docs/lab5-exercize.md
4. https://blog.csdn.net/a747979985/article/details/99712515
5. https://blog.csdn.net/a747979985/article/details/99551678
6. https://blog.csdn.net/bysui/article/details/51868917