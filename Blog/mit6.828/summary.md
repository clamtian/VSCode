# 1. xv6启动流程

## 1.1 BIOS 

内存低 1M 的顶部 64K 都是分配给 BIOS 的。

BIOS 程序不需要由谁加载，本身便固化在ROM只读存储器中；开机的一瞬间 cs:ip 便被初始化为0xf000 : 0xfff0。开机的时候处于实模式，其等效地址为0xffff0。

BIOS 程序做了以下事情：

• POST 自检，检验主板，内存，各类外设

• 对设备进行初始化

• 建立中断表、构建 BIOS 数据区、加载中断服务程序

• 权力交接给 MBR

BIOS 最后一项工作便是加载启动盘最开始那个扇区里面的引导程序到0x7c00，然后跳去执行。

## 1.2 Bootloader

xv6 并没有实际构造 MBR 结构，最开始的那个扇区写入的是 bootlock，bootlock是由 bootasm.S 和 bootmain.c 两文件经过编译得到的，这两个文件组成的程序就充当了 MBR 和 Bootloader 的角色。

bootasm.S 主要做了一件事：进入保护模式，主要分三步

* 打开 A20：地址总线可以使用 32 跟，寻址能力达到 4G；
* 构建加载 GDT：构建临时 GDT 并将其地址加载到 GDTR 寄存器中；
* 设置 CR0 寄存器：将 CR0 寄存器的 PE 位置1 ，开启保护模式。

执行完这三步后，执行 bootmain.c 程序，将操作系统内核加载到内存中，整个内核就是一个 elf 文件，内核在磁盘上，所以要先读取磁盘。

加载内核分为两步：首先将 elf 文件头加载到 0x10000 的位置，然后将 elf 文件加载到 0x100000 的位置处。接下来就将权利移交给内核，由内核完成接下来的启动。

## 1.3 Kernel

启动的后半部分都交由内核来做，主要三件事：

* 开启分页机制
* 对系统的各个部分进行初始化
* BSP 启动 APs
  
Bootloader 后首先会进入到 entry.S，

















> MBR 和 Bootloader 的区别
> 
> 广义上可以认为他们是相同的，Bootlaoder 表示主引导程序代码，而MBR （Main Boot Record 主引导记录区） 包括 Bootloader 和  DPT（Disk Partition Table硬盘分区表），DPT记录了磁盘的分区情况，由并列的四项组成。所以硬盘最多可以有四个分区。

> 段寄存器：
> 
> 每个处理器有 6 个段寄存器有，CS 代码段，SS 栈段，DS 数据段，ES FS GS 附加数据段，xv6 里只用到了前4 个段寄存器，FS GS 没有使用。实模式下，段寄存器里面的存放的是段基址，保护模式下，段寄存器里面存放的是段选择子。当然这只是可见部分，段寄存器还有不可见部分作为段描述符的缓存。所以在保护模式下，有了段寄存器之后，地址转换的时候不用每次都要根据段选择子去索引段描述符获取段基址，有缓存的话直接去缓存里面获取即可，加快了地址转换的速度。要访问一个内存段的时候，这个段的段选择子必须加载到某段寄存器，所以一个系统虽然可以定义上千个段，但是当前使用的段最多就只有6 个。当然这只是单个处理器，每个处理器都有6 个段寄存器，有各自的GDT，有各自定义的内存段。

> 控制寄存器
>
> 每个处理器有5 个控制寄存器，每个寄存器32 位：CR0、CR1、CR2、CR3和CR4。其中发生缺页异常的时候，CR2 里面就会存放引发缺页的那个地址，CR3存放页目录的地址(物理地址)。

> GDTR 寄存器
>
> GDT 是硬件支持的一个数据结构，专门有个寄存器GDTR 指示GDT 的起始位置和大小，GDT 的位置信息加载到GDTR 之后，CPU 才知道GDT 在哪。

> EIP 寄存器
>
> EIP寄存器用来存储CPU要读取指令的地址，CPU通过EIP寄存器读取即将要执行的指令。每次CPU执行完相应的汇编指令之后，EIP寄存器的值就会增加。