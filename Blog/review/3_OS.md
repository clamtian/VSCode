先明确一点，操作系统是一个抽象的概念，就像C++中的类一样。操作系统中各种细分的概念（进程、线程和文件系统等）都是一个general的概念，具体的实现可以有很多不同的方式。在复习这块内容的时候要把抽象的概念和xv6中具体的实现结合起来。

# 1. 什么是操作系统

操作系统位于硬件资源之上，管理硬件资源; 应⽤程序之下，为应⽤程序提供服务，同时管理应⽤程序

## 1、资源分配，资源回收

计算机必要的硬件资源⽆⾮就是 CPU、内存、硬盘、I/O设备。⽽这些资源总是有限的，因此需要有效管理，资源管理最终只有两个问题：资源分配、资源回收。

资源分配： 体现在CPU上，⽐如进程调度，多个进程同时请求CPU下，应该给哪⼀个进程呢？再⽐如内存分配，内存不够了怎么办？A进程⾮法访问了B进程的内存地址怎么办？内存内、外碎⽚问题等。

资源回收： 考虑内存回收后的合并等等。

## 2、为应⽤程序提供服务

操作系统将硬件资源的操作封装起来，提供相对统⼀的接⼝（系统调⽤）供开发者调⽤。如果没有操作系统，应⽤程序将直接⾯对硬件，除去给开发者带来的编程困难不说，直接访问硬件，使⽤不当极有可能直接损坏硬件资源。

## 3、管理应⽤程序

即控制进程的⽣命周期：进程开始时的环境配置和资源分配、进程结束后的资源回收、进程调度等。

# 2. 进程

## 2.1 进程的概念

我们编译的代码可执⾏⽂件只是储存在硬盘的静态⽂件，运⾏时被加载到内存，CPU执⾏内存中指令，这个运⾏的程序被称为进程。

进程是对运⾏时程序的封装，操作系统进⾏资源调度和分配的基本单位。

## 2.2 进程的实现--进程表(就是xv6中的ENV结构体)

为了实现进程模型，操作系统维护着⼀张表格(⼀个结构数组)，即进程表。

每个进程占有⼀个进程表项。(有些著作称这些为进程控制块)，该表项包含了⼀个进程状态的重要信息

包括程序计数器、堆栈指针、内存分配状况、所打开⽂件的状态、账号的调度信息，以及其他在进程由运⾏态转换到就绪态或阻塞态时必须保存的信息，从⽽保证该进程随后能再次启动，就像从未中断过⼀样

进程表项是进程存在的唯⼀标识，其包括以下信息：
1. 进程描述信息： 进程标识符、⽤户标识符等;
2. 进程控制和管理信息： 进程状态，进程优先级等;
3. 进程资源分配清单： 虚拟内存地址空间信息，打开⽂件列表，IO设备信息等;
4. CPU相关信息： 当进程切换时，CPU寄存器的值都被保存在相应PCB中，以便CPU重新执⾏该进程时能从断点处继续执⾏;

## 2.3 并发与并行

1. 单个核⼼在很短时间内分别执⾏多个进程，称为并发
2. 多个核⼼同时执⾏多个进程称为并⾏
3. 对于并发来说，CPU需要从⼀个进程切换到另⼀个进程，这个过程需要保存进程的状态信息

## 2.4 进程的状态

除了创建和结束，程序基本有三个状态：（三状态和五状态）

运⾏态： 该时刻进程占⽤CPU

就绪态： 可运⾏，由于其他进程处于运⾏状态⽽暂时停⽌运⾏

阻塞态： 该进程正在等待某⼀事件发⽣（如等待输⼊/输出操作的完成）⽽暂时停⽌运⾏

特点：

1. 就绪态和运⾏态可以相互转换，其它的都是单向转换。就绪态的进程通过调度算法从⽽获得CPU 时间，转为运⾏状态；
2. 运⾏态的进程，在分配给它的 CPU 时间⽚⽤完之后就会转为就绪状态，等待下⼀次调度。
3. 阻塞态是缺少需要的资源从⽽由运⾏态转换⽽来，但是该资源不包括 CPU 时间，缺少CPU 时间会从运⾏态转换为就绪态。
   
其中就绪态和阻塞态还可以细分：

⽐如read系统调⽤阻塞，进程会占⽤内存空间，这是⼀种浪费⾏为，于是操作系统会跟内存管理中物理⻚置换到磁盘⼀样的⾏为，把阻塞的进程置换到磁盘中，此时进程未占⽤物理内存，我们称之为挂起;

![](image/3_1.png)

# 3. 进程切换为何⽐线程慢

涉及到虚拟内存的问题，进程切换涉及虚拟地址空间的切换⽽线程不会。因为每个进程都有⾃⼰的虚拟地址空间，⽽线程是共享所在进程的虚拟地址空间的，所以同⼀个进程中的线程进⾏线程切换时不涉及虚拟地址空间的转换。

把虚拟地址转换为物理地址需要查找⻚表，⻚表查找是⼀个很慢的过程（⾄少访问2次内存），因此通常使⽤Cache来缓存常⽤的地址映射，这样可以加速⻚表查找，这个cache就是TLB（快表）。

由于每个进程都有⾃⼰的虚拟地址空间，那么显然每个进程都有⾃⼰的⻚表，那么当进程切换后⻚表也要进⾏切换，⻚表切换后TLB就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运⾏会变慢，⽽线程切换则不会导致TLB失效，因为线程线程⽆需切换地址空间，这也就是进程切换要⽐同进程下线程切换慢的原因。

# 4. 守护进程

守护进程是指在后台运⾏的，没有控制终端与它相连的进程。它独⽴于控制终端，周期性地执⾏某种任务。

Linux的⼤多数服务器就是⽤守护进程的⽅式实现的，如web服务器进程http等。

# 5. 僵尸进程

多进程程序，⽗进程⼀般需要跟踪⼦进程的退出状态，当⼦进程退出，⽗进程在运⾏，⼦进程必须等到⽗进程捕获到了⼦进程的退出状态才真正结束。在⼦进程结束后，⽗进程读取状态前，此时⼦进程为僵⼫进程。

设置僵⼫进程的⽬的是维护⼦进程的信息，以便⽗进程在以后某个时候获取。这些信息⾄少包括进程ID，进程的终⽌状态，以及该进程使⽤的CPU时间。

所以当终⽌⼦进程的⽗进程调⽤wait或waitpid时就可以得到这些信息。但是⼦进程停⽌在僵⼫态会占据内核资源，所以需要避免僵⼫进程的产⽣或⽴即结束⼦进程的僵⼫态。

# 6. 多进程

进程结构由以下⼏个部分组成：代码段、堆栈段、数据段。代码段是静态的⼆进制代码，多个程序可以共享。

⽗进程创建⼦进程之后，⽗、⼦进程除了pid外，⼏乎所有的部分⼏乎⼀样。⽗、⼦进程共享全部数据，⼦进程在写数据时会使⽤写时复制技术将公共的数据重新拷⻉⼀份，之后在拷⻉出的数据上进⾏操作；不是对同⼀块数据进⾏操作；

如果⼦进程想要运⾏⾃⼰的代码段，还可以通过调⽤execv()函数􁯿新加载新的代码段，之后就和⽗进程独⽴开了。














