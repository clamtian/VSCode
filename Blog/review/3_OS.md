先明确一点，操作系统是一个抽象的概念，就像C++中的类一样。操作系统中各种细分的概念（进程、线程和文件系统等）都是一个general的概念，具体的实现可以有很多不同的方式。在复习这块内容的时候要把抽象的概念和xv6中具体的实现结合起来。

# 1. 什么是操作系统

操作系统位于硬件资源之上，管理硬件资源; 应⽤程序之下，为应⽤程序提供服务，同时管理应⽤程序

## 1、资源分配，资源回收

计算机必要的硬件资源⽆⾮就是 CPU、内存、硬盘、I/O设备。⽽这些资源总是有限的，因此需要有效管理，资源管理最终只有两个问题：资源分配、资源回收。

资源分配： 体现在CPU上，⽐如进程调度，多个进程同时请求CPU下，应该给哪⼀个进程呢？再⽐如内存分配，内存不够了怎么办？A进程⾮法访问了B进程的内存地址怎么办？内存内、外碎⽚问题等。

资源回收： 考虑内存回收后的合并等等。

## 2、为应⽤程序提供服务

操作系统将硬件资源的操作封装起来，提供相对统⼀的接⼝（系统调⽤）供开发者调⽤。如果没有操作系统，应⽤程序将直接⾯对硬件，除去给开发者带来的编程困难不说，直接访问硬件，使⽤不当极有可能直接损坏硬件资源。

## 3、管理应⽤程序

即控制进程的⽣命周期：进程开始时的环境配置和资源分配、进程结束后的资源回收、进程调度等。

# 2. 进程

## 2.1 进程的概念

我们编译的代码可执⾏⽂件只是储存在硬盘的静态⽂件，运⾏时被加载到内存，CPU执⾏内存中指令，这个运⾏的程序被称为进程。

进程是对运⾏时程序的封装，操作系统进⾏资源调度和分配的基本单位。

## 2.2 进程的实现--进程表(就是xv6中的ENV结构体)

为了实现进程模型，操作系统维护着⼀张表格(⼀个结构数组)，即进程表。

每个进程占有⼀个进程表项。(有些著作称这些为进程控制块)，该表项包含了⼀个进程状态的重要信息

包括程序计数器、堆栈指针、内存分配状况、所打开⽂件的状态、账号的调度信息，以及其他在进程由运⾏态转换到就绪态或阻塞态时必须保存的信息，从⽽保证该进程随后能再次启动，就像从未中断过⼀样

进程表项是进程存在的唯⼀标识，其包括以下信息：
1. 进程描述信息： 进程标识符、⽤户标识符等;
2. 进程控制和管理信息： 进程状态，进程优先级等;
3. 进程资源分配清单： 虚拟内存地址空间信息，打开⽂件列表，IO设备信息等;
4. CPU相关信息： 当进程切换时，CPU寄存器的值都被保存在相应PCB中，以便CPU重新执⾏该进程时能从断点处继续执⾏;

## 2.3 并发与并行

1. 单个核⼼在很短时间内分别执⾏多个进程，称为并发
2. 多个核⼼同时执⾏多个进程称为并⾏
3. 对于并发来说，CPU需要从⼀个进程切换到另⼀个进程，这个过程需要保存进程的状态信息

## 2.4 进程的状态

除了创建和结束，程序基本有三个状态：（三状态和五状态）

运⾏态： 该时刻进程占⽤CPU

就绪态： 可运⾏，由于其他进程处于运⾏状态⽽暂时停⽌运⾏

阻塞态： 该进程正在等待某⼀事件发⽣（如等待输⼊/输出操作的完成）⽽暂时停⽌运⾏

特点：

1. 就绪态和运⾏态可以相互转换，其它的都是单向转换。就绪态的进程通过调度算法从⽽获得CPU 时间，转为运⾏状态；
2. 运⾏态的进程，在分配给它的 CPU 时间⽚⽤完之后就会转为就绪状态，等待下⼀次调度。
3. 阻塞态是缺少需要的资源从⽽由运⾏态转换⽽来，但是该资源不包括 CPU 时间，缺少CPU 时间会从运⾏态转换为就绪态。
   
其中就绪态和阻塞态还可以细分：

⽐如read系统调⽤阻塞，进程会占⽤内存空间，这是⼀种浪费⾏为，于是操作系统会跟内存管理中物理⻚置换到磁盘⼀样的⾏为，把阻塞的进程置换到磁盘中，此时进程未占⽤物理内存，我们称之为挂起;

![](image/3_1.png)

# 3. 进程切换为何⽐线程慢

涉及到虚拟内存的问题，进程切换涉及虚拟地址空间的切换⽽线程不会。因为每个进程都有⾃⼰的虚拟地址空间，⽽线程是共享所在进程的虚拟地址空间的，所以同⼀个进程中的线程进⾏线程切换时不涉及虚拟地址空间的转换。

把虚拟地址转换为物理地址需要查找⻚表，⻚表查找是⼀个很慢的过程（⾄少访问2次内存），因此通常使⽤Cache来缓存常⽤的地址映射，这样可以加速⻚表查找，这个cache就是TLB（快表）。

由于每个进程都有⾃⼰的虚拟地址空间，那么显然每个进程都有⾃⼰的⻚表，那么当进程切换后⻚表也要进⾏切换，⻚表切换后TLB就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运⾏会变慢，⽽线程切换则不会导致TLB失效，因为线程线程⽆需切换地址空间，这也就是进程切换要⽐同进程下线程切换慢的原因。

# 4. 守护进程

守护进程是指在后台运⾏的，没有控制终端与它相连的进程。它独⽴于控制终端，周期性地执⾏某种任务。

Linux的⼤多数服务器就是⽤守护进程的⽅式实现的，如web服务器进程http等。

# 5. 僵尸进程

多进程程序，⽗进程⼀般需要跟踪⼦进程的退出状态，当⼦进程退出，⽗进程在运⾏，⼦进程必须等到⽗进程捕获到了⼦进程的退出状态才真正结束。在⼦进程结束后，⽗进程读取状态前，此时⼦进程为僵⼫进程。

设置僵⼫进程的⽬的是维护⼦进程的信息，以便⽗进程在以后某个时候获取。这些信息⾄少包括进程ID，进程的终⽌状态，以及该进程使⽤的CPU时间。

所以当终⽌⼦进程的⽗进程调⽤wait或waitpid时就可以得到这些信息。但是⼦进程停⽌在僵⼫态会占据内核资源，所以需要避免僵⼫进程的产⽣或⽴即结束⼦进程的僵⼫态。

## 如何避免僵尸进程

1. 最简单的⽅法:⽗进程通过 wait() 和 waitpid() 等函数等待⼦进程结束，但是，这会导致⽗进程挂起;
2. 如果⽗进程要处理的事情很多，不能够挂起，通过 signal() 函数⼈为处理信号SIGCHLD:只要有⼦进程退出⾃动调⽤指定好的回调函数，因为⼦进程结束后， ⽗进程会收到该信号SIGCHLD ，可以在其回调函数⾥调⽤ wait() 或 waitpid() 回收;
3. 如果⽗进程不关⼼⼦进程什么时候结束，那么可以⽤signal（SIGCHLD, SIG_IGN）通知内核:⾃⼰对⼦进程的结束不感兴趣，⽗进程忽略此信号，那么⼦进程结束后，内核会回收，并不再给⽗进程发送信号;

# 6. 多进程

进程结构由以下⼏个部分组成：代码段、堆栈段、数据段。代码段是静态的⼆进制代码，多个程序可以共享。

⽗进程创建⼦进程之后，⽗、⼦进程除了pid外，⼏乎所有的部分⼏乎⼀样。⽗、⼦进程共享全部数据，⼦进程在写数据时会使⽤写时复制技术将公共的数据重新拷⻉⼀份，之后在拷⻉出的数据上进⾏操作；不是对同⼀块数据进⾏操作；

如果⼦进程想要运⾏⾃⼰的代码段，还可以通过调⽤execv()函数重新加载新的代码段，之后就和⽗进程独⽴开了。

# 7. 进程调度算法

## 批处理系统中的调度

**先来先服务**

⾮抢占式的调度算法，按照请求的顺序进⾏调度。有利于⻓作业，但不利于短作业，因为短作业必须⼀直等待前⾯的⻓作业执⾏完毕才能执⾏，⽽⻓作业⼜需要执⾏很⻓时间，造成了短作业等待时间过⻓。

**最短作业优先**

⾮抢占式的调度算法，按估计运⾏时间最短的顺序进⾏调度。⻓作业有可能会饿死，处于⼀直等待短作业执⾏完毕的状态。因为如果⼀直有短作业到来，那么⻓作业永远得不到调度。

**最短剩余时间优先**

最短作业优先的抢占式版本，按剩余运⾏时间的顺序进⾏调度。当⼀个新的作业到达时，其整个运⾏时间与当前进程的剩余时间作⽐较。如果新的进程需要的时间更少，则挂起当前进程，运⾏新的进程。否则新的进程等待。

## 交互式系统中的调度

**时间片轮转调度**

将所有就绪进程按 先来先服务（FCFS） 的原则排成⼀个队列，每次调度时，把 CPU 时间分配给队⾸进程，该进程可以执⾏⼀个时间⽚。当时间⽚⽤完时，由计时器发出时钟中断，调度程序便停⽌该进程的执⾏，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队⾸的进程。

**优先级调度**

为每个进程分配⼀个优先级，按优先级进⾏调度。为了防⽌低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级

**多级队列**

⼀个进程需要执⾏ 100 个时间⽚，如果采⽤时间⽚轮转调度算法，那么需要交换 100 次。多级队列是为这种需要连续执⾏多个时间⽚的进程考虑，它设置了多个队列，每个队列时间⽚⼤⼩都不同，例如 1,2,4,8,..。进程在第⼀个队列没执⾏完，就会被移到下⼀个队列。这种⽅式下，之前的进程只需要交换 7 次。

每个队列优先权也不同，最上⾯的优先权最⾼。因此只有上⼀个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间⽚轮转调度算法和优先级调度算法的结合。

**最短进程优先**

如果我们将每⼀条命令的执⾏看作是⼀个独⽴的“作业”，则我们可以通过⾸先运⾏最短的作业来使响应事件最短

# 8. 进程通信

⽆名管道、有名管道、信号、消息队列、共享内存、信号量

## 8.1 无名管道

**特点**

1. 半双⼯，数据在同⼀时刻只能在⼀个⽅向上流动
2. 数据只能从管道的⼀端写⼊，从另⼀端读出
3. 写⼊管道中的数据遵循先⼊先出的规则
4. 管道所传送的数据是⽆格式的，这要求管道的读出⽅与写⼊⽅必须事先约定好数据的格式，如多少字节算⼀个消息等
5. 管道不是普通的⽂件，不属于某个⽂件系统，其只存在于内存中
6. 管道在内存中对应⼀个缓冲区。不同的系统其⼤⼩不⼀定相同
7. 从管道读数据是⼀次性操作，数据⼀旦被读⾛，它就从管道中被抛弃，释放空间以便写更多的数据
8. 管道没有名字，只能在具有公共祖先的进程（⽗进程与⼦进程，或者两个兄弟进程，具有亲缘关系）之间使⽤
9. 存在阻塞⽅式

**pipe函数**

```javascript
#include <unistd.h>
/**
* 创建无名管道
* @param pipefd 为int型数组的首地址，其存放了管道的文件描述符
* pipefd[0]、pipefd[1]
* @return 创建成功返回0，创建失败返回-1
*/
int pipe(int pipefd[2]);
/**
* 当一个管道建立时，它会创建两个文件描述符 fd[0] 和 fd[1]. 其中
* fd[0] 固定用于读管道，而 fd[1] 固定用于写管道。
* 一般文件 I/O 的函数都可以用来操作管道(lseek() 除外)
*/
```

**读写管道四种进程情况**

第一种：

1. 如果写端没有关闭，管道中没有数据，这个时候读管道进程去读管道会阻塞;
2. 如果写段没有关闭，管道中有数据，这个时候读管道进程就会将数据读出来，下⼀次读没有数据就会阻塞;

第二种：

管道所有的写端关闭，读进程去读管道的内容，读取全部内容，最后返回0;

第三种：

所有读端没有关闭，如果管道被写满了，写管道进程写管道会被阻塞;

第四种：

所有的读端被关闭，写管道进程写管道会收到⼀个信号，然后退出。

**读管道**

管道中有数据：read返回实际读到的字节数

管道中⽆数据:
1. 管道写端被全部关闭，read返回0 (相当于读到⽂件结尾)
2. 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)

**写管道**

管道读端全部被关闭：进程异常终⽌(也可使⽤捕捉SIGPIPE信号，使进程终⽌);

管道读端没有全部关闭：
1. 管道已满，write阻塞
2. 管道未满，write将数据写⼊，并返回实际写⼊的字节数

**查看管道缓冲区**

```javascript
/**
 * 该函数可以通过 name 参数查看不同的属性值
 * @param fd 文件描述符
 * @param name _PC_PIPE_BUF, 查看管道缓冲区大小
 * _PC_NAME_MAX, 文件名字字节数的上限
 * @return 成功：name 的值决定返回值的意义；失败：返回-1

long fpathconf(int fd, int name);
```

**设置为非阻塞的方法**

```javascript
// 获取原来的flags
int flags = fcntl(fd[0], F_GETFL);

// 设置新的flags
flag |= O_NONBLOCK;

// flags = flags | O_NONBLOCK
fcntl(fd[0], F_SETFL, flags);
```

## 8.2 命名管道

命名管道（FIFO）不同于⽆名管道之处在于它提供了⼀个路径名与之关联，以 FIFO 的⽂件形式存在于⽂件系统中，这样，即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据.

**与无名管道不同**

1. FIFO 在⽂件系统中作为⼀个特殊的⽂件⽽存在，但 FIFO 中的内容却存放在内存中;
2. 当使⽤ FIFO 的进程退出后，FIFO ⽂件将继续保存在⽂件系统中以便以后使⽤;
3. FIFO 有名字，不相关的进程可以通过打开命名管道进⾏通信.

**创建有名管道**

```javascript
#include <sys/types.h>
#include <sys/stat.h>

/**
 * 命名创建的管道
 * @param pathname 普通的路径名，也就是创建后 FIFO 的名字
 * @param mode 文件的权限，与打开普通文件的 open() 函数中的 mode 参数相同（0666）
 * @return 成功：0；失败：如果文件已经存在，则会返回-1
 */
int mkfifo(const char *pathname, mode_t mode);
```

**读写管道**

⼀个为只读⽽打开⼀个管道的进程会阻塞直到另外⼀个进程为只写打开该管道;

⼀个为只写⽽打开⼀个管道的进程会阻塞直到另外⼀个进程为只读打开该管道.

读管道：

1. 管道中有数据，read返回实际读到的字节数
2. 管道中⽆数据：
   
   管道写端被全部关闭，read返回0 (相当于读到⽂件结尾);

   写端没有全部被关闭，read阻塞等待.

写管道：

1. 管道读端全部被关闭， 进程异常终⽌(也可使⽤捕捉SIGPIPE信号，使进程终⽌);
2. 管道读端没有全部关闭：
   
   管道已满，write阻塞;
   管道未满，write将数据写⼊，并返回实际写⼊的字节数。

## 8.3 共享存储映射

存储映射I/O (Memory-mapped I/O) 使⼀个磁盘⽂件与存储空间中的⼀个缓冲区相映射.于是当从缓冲区中取数据，就相当于读⽂件中的相应字节。于此类似，将数据存⼊缓冲区，则相应的字节就⾃动写⼊⽂件。

这样，就可在不适⽤read和write函数的情况下，使⽤地址（指针）完成I/O操作，进程就可以直接通过读写内存来操作⽂件.

共享内存可以说是最有⽤的进程间通信⽅式，也是最快的IPC形式, 因为进程可以直接读写内存，⽽不需要任何数据的拷⻉.

## 8.4 消息队列

**基本原理**

A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。

**特点**

1. 消息队列是保存在内核中的消息链表，每个消息体都是固定⼤⼩的存储块。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。
2. 如果没有释放消息队列或者没有关闭操作系统，消息队列会⼀直存在。
   
**缺点**

1. 通信不及时，附件也有⼤⼩限制。
2. 消息队列不适合⽐较⼤数据的传输，每个消息体都有⼀个最⼤⻓度的限制，同时所有队列所包含的全部消息体的总⻓度也是有上限
3. 消息队列通信过程中，存在⽤户态与内核态之间的数据拷⻉开销

## 8.5 信号

信号是linux进程通信的最古⽼的⽅式;

信号是软件中断，它是在软件层次上对中断机制的⼀种模拟，是⼀种异步通信的⽅式 。信号可以导致⼀个正在运⾏的进程被另⼀个正在运⾏的异步进程中断，转⽽处理某⼀个突发事件;

信号可以直接进⾏⽤户空间进程和内核空间进程的交互，内核进程可以利⽤它来通知⽤户空间进程发⽣了哪些系统事件.

**信号的特点**

1. 简单
2. 不能携带大量信息
3. 满⾜某个特定条件才发送

**信号编号**

不存在编号为0的信号：

1. 其中1-31号信号称之为常规信号（也叫普通信号或标准信号）
2. 34-64称之为实时信号，驱动编程与硬件相关。名字上区别不⼤。⽽前32个名字各不相同
   
⽐较重要的⼀些，需要记住的⼏个信号：

1. SIGINT 当⽤户按下了<Ctrl+C>组合键时，⽤户终端向正在运⾏中的由该终端启动的程序发出此信号，终⽌进程
2. SIGQUIT ⽤户按下<ctrl+>组合键时产⽣该信号，⽤户终端向正在运⾏中的由该终端启动的程序发出些信号,终⽌进程
3. SIGSEGV 指示进程进⾏了⽆效内存访问(段错误), 终⽌进程并产⽣core⽂件
4. SIGPIPE Broken pipe向⼀个没有读端的管道写数据,终⽌进程
5. SIGCHLD ⼦进程结束时，⽗进程会收到这个信号,忽略这个信号

**信号的状态**

产⽣：
1. 当⽤户按某些终端键时，将产⽣信号
2. 硬件异常将产⽣信号
3. 软件异常将产⽣信号
4. 调⽤系统函数(如：kill、raise、abort)将发送信号
5. 运⾏ kill /killall命令将发送信号
   
未决状态：没有被处理

递达状态：信号被处理了

**阻塞信号集和未决信号集**

阻塞信号集：

将某些信号加⼊集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(处理发⽣在解除屏蔽后)

未决信号集合：

信号产⽣，未决信号集中描述该信号的位⽴刻翻转为1，表示信号处于未决状态。当信号被处理对应位翻转回为0。这⼀时刻往往⾮常短暂.

# 9. 不可重⼊、可重⼊函数

如果有⼀个函数不幸被设计成为这样：不同任务调⽤这个函数时可能修改其他任务调⽤这个函数的数据，从⽽导致不可预料的后果。

这样的函数是不安全的函数，也叫不可重入函数;

**不可重⼊函数**

1. 函数体内使⽤了静态的数据结构;
2. 函数体内调⽤了malloc() 或者 free() 函数(谨慎使⽤堆);
3. 函数体内调⽤了标准 I/O 函数;

**可重入函数**

1. 所谓可重入是指⼀个可以被多个任务调⽤的过程，任务在调⽤时不必担⼼数据是否会出错;
2. 在写函数时候尽量使⽤局部变量（例如寄存器、栈中的变量）;
3. 对于要使⽤的全局变量要加以保护（如采取关中断、信号量等互斥⽅法），这样构成的函数就⼀定是⼀个可重入的函数.

# 10. 线程

## 10.1 线程的特点

1. 线程是轻量级进程(light-weight process)，也有PCB，创建线程使⽤的底层函数和进程⼀样，都是clone;
2. 从内核⾥看进程和线程是⼀样的，都有各⾃不同的PCB;
3. 进程可以蜕变成线程;
4. 在linux下，线程最是⼩的执⾏单位；进程是最⼩的分配资源单位。

实际上，⽆论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调⽤同⼀个内核函数 clone 。

1. 如果复制对⽅的地址空间，那么就产出⼀个“进程”;
2. 如果共享对⽅的地址空间，就产⽣⼀个“线程”。
3. 
Linux内核是不区分进程和线程的, 只在⽤户层⾯上进⾏区分。所以，线程所有操作函数pthread_* 是库函数，⽽⾮系统调⽤。

## 10.2 三种线程的实现

**⽤户线程**

⽤户空间实现的线程，由基于⽤户态的线程库管理

优点：
1. 管理不需要内核直接参与，因此可⽤于不⽀持线程技术的操作系统;
2. ⽤户线程切换由线程库调度，不需要⽤户态与内核态之间转换。

缺点：
1. 由于不由操作系统调度，⼀旦⽤户线程发起系统调⽤⽽阻塞，那么此进程下⽤户线程都⽆法运⾏;
2. ⼀旦某个⽤户线程正在运⾏，只有当其交出CPU执⾏权，其他⽤户线程才可以运⾏，⽆法被打断，因为只有操作系统才有权限打断运⾏，但是操作系统不直接参与调度;
3. ⽤户线程操作系统⽆法感知，CPU资源是直接分配给线程所在的进程，因此分到具体⽤户线程的时间⽚就较短了。其TCB线程控制块⽆法被操作系统所感知，因此⽤户线程的创建、终⽌、同步、调度等都不是由操作系统直接参与。

**内核线程**

由操作系统管理、调度，其TCB是存放在内核中。⼀般由操作系统事先创建内核线程集(类似于线程池)，数量有限。

优点：
1. 当⼀个内核线程发起系统调⽤阻塞时不会影响其它内核线程的执⾏;
2. 操作系统将CPU资源直接分配给内核线程，更多CPU时间。
   
缺点：
1. 需要由内核来维护内核线程的上下⽂信息及运⾏状态等，占⽤内核资源;
2. 内核线程创建、终⽌、切换都是在内核中进⾏，开销⽐较⼤。

**轻量级线程LWP**

内核⽀持的⽤户线程，像普通进程⼀样被调度，其类似于进程中的执⾏线程。

每个LWP都需要⼀个内核线程的⽀持(CPU资源分配、调度)，实际上⽤户线程是运⾏在LWP上的。

## 10.3 线程资源

**线程共享资源**

1. ⽂件描述符表
2. 每种信号的处理⽅式
3. 当前⼯作⽬录
4. ⽤户ID和组ID

**线程非共享资源**

1. 线程id
2. 处理器现场和栈指针(内核栈)
3. 独⽴的栈空间(⽤户空间栈)
4. errno变量
5. 信号屏蔽字
6. 调度优先级

## 10.4 线程的优缺点

**优点**

1. 提⾼程序并发性
2. 开销⼩
3. 数据通信、共享数据⽅便

**缺点**

1. 库函数，不稳定
2. 调试、编写困难、gdb不⽀持
3. 对信号⽀持不好

## 10.5 线程如何减少开销

1. 线程创建快，进程创建需要资源管理信息，⽐如内存管理信息和⽂件管理信息，⽽线程创建后是共享其所属进程的资源管理信息;
2. 线程终⽌时间快，需要回收的仅有少量寄存器和私有的栈区;
3. 线程切换快，因为线程切换仅涉及到少量寄存器和栈区，⽽进程上下⽂切换有CPU寄存器和程序计数器(CPU上下⽂)、虚拟内存空间、⻚表切换、TLB失效等;
4. 线程因为创建时共享了其所述进程绝⼤多数资源，因此天⽣具有很好的线程间通信交互效率。

## 10.6 线程通信

线程间的通信⽬的主要是⽤于线程同步。所以线程没有像进程通信中的⽤于数据交换的通信机制。

同⼀进程的不同线程共享同⼀份内存区域，所以线程之间可以⽅便、快速地共享信息。只需要将数据复制到共享（全局或堆）变􁰁中即可。但是需要避免出现多个线程试图同时修改同⼀份信息。

# 11. 页面置换算法

请求分页管理方式中，当需要调入页面到内存中，但此时内存已满，就需要从内存中按照一定的置换算法决定将哪个页面取出将内存给调入的页面。本文将介绍几种页面置换算方法。

## 11.1 最佳置换算法(OPT)

算法思想：每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。

最佳置换算法可以保证最低的缺页率，但是实际上，只有进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面的访问序列。因此，最佳置换算法是无法实现的。

## 11.2 先进先出置换算法(FIFO)

算法思想：每次选择淘汰的页面是最早进入内存的页面。

当为进程分配的物理块数增大时，缺页次数不减反增的异常现象称为贝莱迪（Belay）异常。

只有FIFO算法会产生Belay异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应。因为先进入的页面也有可能最经常被访问。因此，算法性能差。

## 11.3 最近最久未使⽤的置换算法（LRU）

算法思想：每次淘汰的页面是最近最久未使用的页面。

实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中t最大的页面，即最近最久未使用。

## 11.4 时钟⻚⾯置换算法

最佳置换算法那性能最好，但无法实现。先进先出置换算法实现简单，但是算法性能差。最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。时钟置换算法是一种性能和开销均平衡的算法。又称CLOCK算法，或最近未用算法（NRU，Not Recently Used）

简单CLOCK算法算法思想：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某个页被访问时，其访问位置1.当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，暂不换出，将访问位改为0，继续检查下一个页面，若第一轮扫描中所有的页面都是1，则将这些页面的访问位一次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）。

## 11.5 最不常⽤算法

记录每个⻚⾯访问次数，当发⽣缺⻚中断时候，将访问次数最少的⻚⾯置换出去，此⽅法需要对每个⻚⾯访问次数统计，额外开销。

# 12. 分段

虚拟内存采⽤的是分⻚技术，也就是将地址空间划分成固定⼤⼩的⻚，每⼀⻚再与内存进⾏映射。

如果使⽤分⻚系统的⼀维地址空间，动态增⻓的特点会导致覆盖问题的出现。

分段的做法是把每个表分成段，⼀个段构成⼀个独⽴的地址空间。每个段的⻓度可以不同，并且可以动态增⻓。

## 12.1 纯分段
分段和分⻚本质上是不同的，⻚⾯是定⻓的⽽段不是。

优点：
1. 共享：有助于⼏个进程之间共享过程和数据。 ⽐如共享库
2. 保护：每个段都可以独⽴地增⼤或减⼩⽽不会影响其他的段

## 12.2 分段和分⻚结合

程序的地址空间划分成多个拥有独⽴地址空间的段，每个段上的地址空间划分成⼤⼩相同的⻚。

这样既拥有分段系统的共享和保护，⼜拥有分⻚系统的虚拟内存功能.

## 12.3 分段与分⻚的⽐较

**对程序员的透明性**

分⻚透明，但是分段需要程序员显式划分每个段。

**地址空间的维度**

分⻚是⼀维地址空间，分段是⼆维的。

**⼤⼩是否可以改变**

⻚的⼤⼩不可变，段的⼤⼩可以动态改变。

**出现的原因**

分⻚主要⽤于实现虚拟内存，从⽽获得更⼤的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独⽴的地址空间并且有助于共享和保护。

# 13. 虚拟内存

属于计算机系统内存管理的⼀种技术，虚拟地址空间构成虚拟内存，它使得应⽤程序认为⾃⼰拥有连续的可⽤内存空间，但实际上是被分隔的多个物理内存⻚、以及部分暂时存储在磁盘上的交换分区所构成的。虚拟内存的实现通过硬件异常、硬件地址翻译、主存、磁盘以及内核软件共同完成

在虚拟内存中的虚拟⻚共分为三种类型：

1. 未分配（没有被进程申请使⽤的，也就是空闲的虚拟内存， 不占⽤虚拟内存磁盘的任何空间）
2. 未缓存（已经分配，但还未加载到内存中的内存⻚）
3. 已缓存（已经加载到内存中的内存⻚（⻚框））

**作用**

高速缓存、内存管理、内存保护

## 13.1 地址空间

地址空间是物理内存的抽象，是⼀个进程可⽤于寻址内存的⼀套地址集合。

## 13.2 分⻚

地址空间被分割成多个块，每⼀块称作⼀⻚或⻚⾯(Page)。每⼀⻚有连续的地址范围，这些⻚被映射到连续的物理内存(⻚框)。

## 13.3 ⻚表

⻚表的⽬的是把虚拟⻚⾯(虚拟地址)映射为⻚框(物理地址)。⻚表给出了虚拟地址与物理地址的映射关系。从数学的⻆度说⻚表是⼀个函数，他的参数是虚拟⻚号，结果是物理⻚⻚框号

## 13.4 TLB加速分⻚

将虚拟地址直接映射到物理地址，⽽不必再访问⻚表，这种设备被称为转换检测缓冲区（TLB）、相联存储器或快表

⼯作过程：将⼀个虚拟地址放⼊MMU中进⾏转换时，硬件⾸先通过将该虚拟⻚号与TLB中所有表项同时进⾏匹配，判断虚拟⻚⾯是否在其中：

1. 虚拟⻚号在TLB中。如果MMU检测⼀个有效的匹配并且访问操作并不违反保护位，则将⻚框号直接从TLB中取出⽽不必访问⻚表。
2. 虚拟⻚号不在TLB中。如果MMU检测到没有有效的匹配项就会进⾏正常的⻚表查询。接着从TLB中淘汰⼀个表项，然后⽤新的⻚表项替换它。

# 14. ⽤户态和内核态

为了使操作系统内核提供⼀个⽆懈可击的进程抽象，处理器必须提供⼀种机制，限制⼀个应⽤可以执⾏的指令以及他可以⽤来访问的地址空间范围。

处理器通常是⽤某个控制寄存器中的⼀个模式位来提供这种观功能的，该寄存器描述了进程当前享有的特权。

当设置了模式位时：进程就运⾏在内核态中。

运⾏在内核态中的进程可以执⾏指令集中的任何指令，并且可以访问系统中的任何内存位置。

没有设置模式位时：

进程就运⾏在⽤户态。⽤户模式中的进程不允许执⾏特权指令。

⽐如：停⽌处理器、改变模式位、或者发起⼀个I/O操作。同时也不允许⽤户态下的进程直接引⽤地址空间中内核空间的代码和数据。

任何这样的尝试都会导致致命的保护故障。⽤户态下的程序必须通过系统调⽤接⼝间接的访问内核代码和数据。

# 15. 为什么需要虚拟内存：（摘⾃ 为什么Linux需要虚拟内存⼀⽂)

1. 虚拟内存可以结合磁盘和物理内存的优势为进程提供看起来速度⾜够快并且容􁰁⾜够⼤的存储
2. 虚拟内存可以为进程提供独⽴的内存空间并引⼊多层的⻚表结构将虚拟内存翻译成物理内存，进程之间可以共享物理内存减少开销，也能简化程序的链接、装载以及内存分配过程;
3. 虚拟内存可以控制进程对物理内存的访问，隔离不同进程的访问权限，提⾼系统的安全性。

# 16. 互斥锁

也叫互斥量，互斥锁是⼀种简单的加锁的⽅法来控制对共享资源的访问，互斥锁只有两种状态,即加锁( lock )和解锁( unlock )

1. 在访问共享资源后临界区域前，对互斥锁进⾏加锁。
2. 在访问完成后释放互斥锁导上的锁。
3. 对互斥锁进⾏加锁后，任何其他试图再次对互斥锁加锁的线程将会被阻塞，直到锁被释放。

# 17. 死锁（DeadLock）

如果⼀个进程集合中的每⼀个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁

## 17.1 资源

可抢占资源：可以从拥有它的进程中抢占⽽不会产⽣任何副作⽤，存储器就是⼀类可抢占资源

不可抢占资源：是指在不引起相关计算失败的情况下，⽆法把它从占有它的进程处抢占过来

## 17.2 必要条件

1. 互斥：每个资源要么已经分配给⼀个进程，要么就是可⽤的
2. 占有和等待：已经得到了某个资源的进程可以再请求新的资源
3. 不可抢占：已经分配给⼀个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放
4. 环路等待：死锁发⽣时，系统中⼀定有由两个或两个以上的进程组成的⼀条环路，该环路中的每个进程都在等待着下⼀个进程所占有的资源。

## 17.3 处理⽅法

### 17.3.1 鸵⻦算法

把头埋在沙⼦⾥，假装根本没发⽣问题。

因为解决死锁问题的代价很⾼，因此鸵⻦算法这种不采取任务措施的⽅案会获得更⾼的性能。当发⽣死锁时不会对⽤户造成多⼤影响，或发⽣死锁的概率很低，可以采⽤鸵⻦算法。

### 17.3.2 死锁检测

**每种类型⼀个资源的死锁检测**

通过检测有向图中是否存在环来实现，从⼀个节点出发进⾏深度优先搜索，对访问过的节点进⾏标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁发⽣

**每种类型多个资源的死锁检测**

每个进程最开始时都不被标记，执⾏过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。

1. 寻找⼀个没有标记的进程Pi，它所请求的资源⼩于或等于A
2. 如果真找到这样⼀个进程，那么将C矩阵的第i⾏向量加到A中，标记该进程，并转回第1步
3. 如果没有这样的进程，那么算法终⽌

### 17.3.3 死锁恢复

**利⽤抢占恢复**

将进程挂起，强⾏取⾛资源给另⼀个进程使⽤，⽤完再放回

**利⽤回滚恢复**

复位到更早的状态，那时它还没有取得所需的资源

**通过杀死进程恢复**

杀掉环中的⼀个进程或多个，牺牲掉⼀个环外进程

### 17.3.4 死锁预防

**破坏互斥条件**

例如假脱机打印机技术允许若⼲个进程同时输出，唯⼀真正请求物理打印机的进程是打印机守护进程。

**破坏占有等待条件**

1. 规定所有进程在开始执⾏前请求所需要的全部资源。
2. 要求当⼀个进程请求资源时，先暂时释放其当前占⽤的所有资源，然后在尝试⼀次获得所需的全部资源。

**破坏不可抢占条件**

1. 保证每⼀个进程在任何时刻只能占⽤⼀个资源，如果请求另⼀个资源必须先释放第⼀个资源
2. 将所有的资源统⼀编号，进程可以在任何时刻提出资源请求，但是所有请求必须按照资源编号的顺序(升序)提出
   
**破坏环路等待**

### 17.3.5 死锁避免

**安全状态**

如果没有死锁发⽣，并且即使所有进程突然请求对资源的最⼤需求，也仍然存在某种调度次序能够使得每⼀个进程运⾏完毕，则称该状态是安全的。

**单个资源的银⾏家算法**

⼀个⼩城镇的银⾏家，他向⼀群客户分别承诺了⼀定的贷款额度，算法要做的是判断对请求的满⾜是否会进⼊不安全状态，如果是，就拒绝请求；否则予以分配。

**多个资源的银⾏家算法**

检查⼀个状态是否安全的算法

1. 查找右边的矩阵是否存在⼀⾏⼩于等于向量 A。如果不存在这样的⾏，那么系统将会发⽣死锁，状态是不安全的。
2. 假若找到这样⼀⾏，将该进程标记为终⽌，并将其已分配资源加到 A 中。
3. 重复以上两步，直到所有进程都标记为终⽌，则状态是安全的。
   
如果⼀个状态不是安全的，需要拒绝进⼊这个状态。

# 18. 读写锁

在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应⽤。为了满⾜当前能够允许多个读出，但只允许⼀个写⼊的需求，线程提供了读写锁来实现。

**读写锁的特点**
1、如果有其它线程读数据，则允许其它线程执⾏读操作，但不允许写操作
2、如果有其它线程写数据，则其它线程都不允许读、写操作

读写锁分为读锁和写锁，规则如下

1. 如果某线程申请了读锁，其它线程可以再申请读锁，但不能申请写锁。
2. 如果某线程申请了写锁，其它线程不能申请读锁，也不能申请写锁。

# 19. 条件变量

与互斥锁不同，条件变量是⽤来等待⽽不是⽤来上锁的，条件变量本身不是锁！

条件变量⽤来⾃动阻塞⼀个线程，直到某特殊情况发⽣为⽌。通常条件变量和互斥锁同时使⽤。

条件变量的两个动作：
1. 条件不满, 阻塞线程
2. 当条件满⾜, 通知阻塞的线程开始⼯作

**条件变量的优缺点**

相较于mutex⽽⾔，条件变量可以减少竞争。

如直接使⽤mutex，除了⽣产者、消费者之间要竞争互斥􁰁以外，消费者之间也需要竞争互斥量;

但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是⽆意义的。有了条件变量机制以后，只有⽣产者完成⽣产，才会引起消费者之间的竞争。提⾼了程序效率。

**条件变量流程分析**

场景: 你是个⽼板，招聘了三个员⼯，但是你不是有了活才去招聘员⼯，⽽是先把员⼯招来，没有活的时候员⼯需要在那⾥等着，⼀旦有了活，你要去通知他们，他们要去抢活⼲，⼲完了再等待，你再有活，再通知他们

# 20. 信号量

信号量⼴泛⽤于进程或线程间的同步和互斥，信号􁰁本质上是⼀个⾮负的整数计数器，它被⽤来控制对公共资源的访问。

编程时可根据操作信号􁰁值的结果判断是否对公共资源具有访问的权限，当信号量值⼤于 0时，则可以访问，否则将阻塞。

PV 原语是对信号量的操作，⼀次 P 操作使信号量减１，⼀次 V 操作使信号量加１。

# 21. 经典的IPC问题

## 21.1 哲学家进餐问题

下⾯是⼀种错误的解法，如果所有哲学家同时拿起左⼿边的筷⼦，那么所有哲学家都在等待其它哲学家吃完并释放⾃⼰⼿中的筷⼦，导致死锁。

为了防⽌死锁的发⽣，可以设置两个条件：

1. 必须同时拿起左右两根筷⼦
2. 只有在两个邻居都没有进餐的情况下才允许进餐

## 21.2 读者-写者问题

允许多个进程同时对数据进⾏读操作，但是不允许读和写以及写和写操作同时发⽣。

# 22. 文件系统

## 22.1 文件

⽂件是⼀种抽象机制，它提供了⼀种在磁上保存信息⽽且⽅便以后读取的⽅法。这种⽅法可以使⽤户不必了解存储信息的⽅法、位置和实际磁盘⼯作⽅式等有关细节

## 22.2 ⽂件命名

win95、win98⽤的都是MS-DOS的⽂件系统，即FAT-16， win98扩展了FAT-16成为FAT-32。

较新版的操作系统NTFS,win8配备ReFS。微软优化FAT,叫作exFAT。prog.c，圆点后⾯的部分称为⽂件扩展名。

## 22.3 ⽂件结构

**字节结构**

把⽂件看成字节序列为操作系统提供了最⼤的灵活度

**记录序列**

⽂件结构上的第⼀步改进，这种模型中，⽂件是具有固定⻓度记录的序列

**树**

⽂件在这种结构中由⼀棵记录树构成，每个记录不必具有相同的⻓度，记录的固定位置上有⼀个键字段。这棵树按“键”字段进⾏排序，从⽽可以对特定“键”进⾏快速查找。

## 22.4 ⽂件类型

1. 普通⽂件
2. ⽬录
3. 字符特殊⽂件（UNIX）
4. 块特殊⽂件（UNIX）

## 22.5 文件访问

**顺序访问**

按顺序读取⽂件的全部字节，早期操作系统只有这种访问⽅式

**随机访问⽂件**

当⽤磁盘存储⽂件时，可以以任何次序读取其中字节或记录的⽂件。许多应⽤程序需要这种类型⽂件

## 22.6 ⽂件属性

除了⽂件名和数据外，所有操作系统还会保存其他的⽂件相关信息，如创建⽇期、时间和⼤⼩等，这些附加的信息称为⽂件属性

## 22.7 ⽂件操作

使⽤⽂件的⽬的是存储信息并⽅便以后检索。对于存储和检索，不同系统提供了不同的操作。

常⻅的⽂件操作（系统调⽤）:

1. create：创建不包含任何数据的⽂件
2. delete：当不再需要某个⽂件时，必须删除该⽂件以释放磁盘空间
3. open：在使⽤⽂件之前，必须先打开⽂件
4. close：访问结束后，不再需要⽂件属性和磁盘地址，这时应该关闭⽂件以释放内部表空间
5. read：在⽂件中读取数据
6. write：向⽂件写数据，写操作⼀般也是从⽂件当前位置开始
7. append：此调⽤是write的限制形式，他只能在⽂件末尾添加数据
8. seek：对于随机访问⽂件，要指定从何处开始获取数据，通常的⽅法是⽤seek系统调⽤把当前位置指针指向⽂件中特定的位置。
9. get attributes：进程运⾏常需要读取⽂件属性
10. set attributes：某些属性是可由⽤户设置的，甚⾄在⽂件创建之后
11. rename：⽤户尝尝要改变已有的名字，rename系统调⽤⽤于这⼀⽬的

## 22.8 目录

⽂件系统通常提供⽬录或⽂件夹⽤于记录⽂件的位置，在很多操作系统中⽬录本身也是⽂件

1. ⼀级⽬录系统：在⼀个⽬录中包含所有⽂件，这有时称为根⽬录
2. 层级⽬录系统：当⽤户有着数以千计的⽂件，为了寻找⽅便。需要层次结构（即⼀个⽬录树）
3. 路径名
   
   **绝对路径名**：它由从根⽬录到⽂件的路径组成。

   Windows ： \usr\ast\maibox

   UNIX ： /usr/ast/mailbox

   路径名的第⼀个字符是分隔符，则这个路径是绝对路径

   **相对路径名**：它常和⼯作⽬录(working directory)(也和当前⽬录(acurrent directory))⼀起使⽤

   **特殊⽬录项**：

   . dot ：指当前⽬录
   
   .. dotdot 指其⽗⽬录

4. 目录操作
   
```javascript
create # 创建目录
delete # 删除目录
opendir # 目录内容可被读取
closedir # 读目录结束
readdir # 返回打开目录下一个目录项
rename # 改变目录名
link # 链接技术允许在多个目录中出现同一个文件
unlink # 删除目录项
```

# 23. ⽂件系统的实现

⽂件存储实现的关键问题是记录各个⽂件分别⽤到哪些磁盘块。不同的操作系统⽤到不同的⽅法

## 23.1 ⽂件系统布局

⽂件系统存放在磁盘上。多数磁盘划分为⼀个或多个分区，每个分区中国有⼀个独⽴的⽂件系统。

磁盘0号扇区称为主引导记录(MBR)，⽤来引导计算机。在MBR结尾是分区表。该表给出每个分区的起始结束地址。

表中的⼀个分区被标记为活动区。在计算机被引导时，BIOS读⼊并执⾏MBR。MBR做的第⼀件事是确定活动分区，读⼊它的第⼀个块，称为引导块，并执⾏之。

引导块中的程序将装载该分区中的操作系统。

## 23.2 ⽂件的实现

**连续分配**

最简单的分配是把每个⽂件作为⼀连串连续数据块存储在磁盘

优势：

1. 实现简单：记录每个⽂件⽤到磁盘块简化为只需记住两个数字即可：第⼀块的磁盘地址和⽂件的块数。给定了第⼀块编号，⼀个简单的加法就可以找到任何其他块的编号

2. 操作性能较好：因为单个操作中就能从磁盘上读出整个⽂件。只需⼀次寻找。

**链表分配**

为每个⽂件构造磁盘块链表。每⼀块的第⼀个字作为指向下⼀块的指针，块的其他部分存放数据。

优势：

1. 可以充分利⽤磁盘块，不会因为磁盘碎⽚浪费存储内存
2. 随机访问快。
   
缺点：

指针占⽤⼀些字节，每个磁盘块存储数据的字节数不再是2的整数次幂。怪异的⼤⼩降低了系统的运⾏效率，每个块前⼏个字节被指向下⼀个块的指针所占据，需要从两个磁盘中获取拼接信息，这就因复制⽽引发额外的开销。

**采⽤内存中的表进⾏链表分配**

取出每个磁盘块的指针字，把他放在内存的⼀个表中，解决链表分配的不⾜。内存中这样的表格称为⽂件分配表(File Allocation Table，FAT)

**i节点**

最后⼀个记录各⽂件分别包含哪些磁盘块的⽅法是给每个⽂件赋予⼀个称为i节点的数据结构，其中列出了⽂件属性和⽂件的磁盘地址。

## 23.3 ⽬录的实现

在读⽂件之前，必须先打开⽂件。打开⽂件时，操作系统利⽤⽤户给出的路径名找到相应的⽬录项。

简单⽬录：包含固定⼤⼩的⽬录，在⽬录项中有磁盘地址和属性

采⽤i节点的系统：把⽂件属性存放在i节点中⽽不是⽬录项中。这种情形下，⽬录项会更短。

## 23.4 共享⽂件

当⼏个⽤户同在⼀个项⽬⾥⼯作时，他们常常需要共享⽂件。

共享⽂件与⽬录的联系称为⼀个链接（link）。这样⽂件系统本身就是⼀个有向⽆环图（DAG），⽽不是⼀棵树。

## 23.5 ⽇志结构⽂件系统

CPU运⾏速度越来越快，磁盘容􁰁越来越⼤，价格越来越便宜（但磁盘速度并没有增快多少），同时内存容􁰁也以指数形式增⻓。

⽽没有得到快速发展的参数是磁道的寻道时间。这些成为了⽂件系统性能的瓶颈，为了解决这⼀问题设计了全新的⽂件系统即⽇志结构⽂件系统（LFS）。

虽然是⼀个很吸引⼈的想法，由于它们和⽂件系统不匹配，该⽂件系统并没有被⼴泛应⽤。

## 23.6 ⽇志⽂件系统

基本的想法是保存⼀个⽤于记录系统下⼀步将要做什么的⽇志。

这样当系统在完成他们即将完成的任务前崩溃时，􁯿新启动后，可以通过查看⽇志，获取崩溃前计划完成的任务，并完成它们。

这样的⽂件⽇志系统，并已经被实际应⽤。微软的NTFS、Linux的 ext3和ReiserFS⽂件系统都使⽤⽇志。

## 23.7 虚拟⽂件系统

将多个⽂件系统整合到⼀个统⼀的结构中。

⼀个Linux系统可以⽤ext2作为根⽂件系统，ext3分区装载在/usr下，另⼀块采⽤ReiserFS⽂件系统的硬盘装载在/home下，以及⼀个ISO 9660的CD-ROM临时装载在/mnt下。从⽤户的观点来看，只有⼀个⽂件系统层级。

它们事实上是多种⽂件系统，对于⽤户和进程是不可⻅的。绝⼤多数Unix操作系统都在使⽤虚拟⽂件系统（Virtual File System, VFS）

# 24. ⽂件系统的管理和优化

## 24.1 磁盘空间管理

⼏乎所有⽂件系统都把⽂件分割成固定⼤⼩的块来存储，各块之间不⼀定相邻

1、块⼤⼩

从历史的观点上来说，⽂件系统将⼤⼩设在1~4KB之间，但现在随着磁盘超过了1TB，还是将块的⼤⼩提升到64KB并且接受浪费的磁盘孔空间，这样也许更好。磁盘空间⼏乎不再会短缺。

2、记录空闲块

**磁盘块链表**

链表的每个块中包含尽可能多的空闲磁盘块号。

通常情况下，采⽤空闲块存放空闲表，这样不会影响存储器

**位图**

在位图中，空闲块⽤1表示，已分配块⽤0表示。

**磁盘配额**

为防⽌⼈们贪⼼⽽占有太多的磁盘空间，⽤户操作系统常常提供⼀种强制性磁盘配额机制。

其思想是系统管理员分给每个⽤户拥有⽂件和块的最⼤数􁰁，操作系统确保每个⽤户不超过分给他们的配额。（配额表、打开⽂件表）

## 24.2 ⽂件系统备份

做磁盘备份主要是处理好两个潜在问题中的⼀个

1. 从意外的灾难中恢复
2. 从错误的操作中恢复

## 24.3 ⽂件系统的⼀致性

很多⽂件系统读取磁盘块，进⾏修改后，再写回磁盘。

如果在修改过的磁盘块全部写回之前系统崩溃，则⽂件系统有可能处于不⼀致状态。

如果⼀些未被写回的块是i节点块、⽬录块或者是包含有空闲表的块时，这个问题尤为严重

## 24.4 ⽂件系统性能

1、⾼速缓存

减少磁盘访问次数技术是块⾼速缓存（block cache）或者缓冲区⾼速缓存（buffer cache）。

本书中，⾼速缓存指的是⼀系列的块，它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。

2、块提取读

在需要⽤到块之前，试图提前将其写⼊⾼速缓存，从⽽提⾼命中率。

块提前读策略只适⽤于实际顺序读取的⽂件。对随机访问⽂件，提前读丝毫不起作⽤。

3、减少磁盘臂运动

把可能顺序访问的块放⼀起，当然最好是同⼀柱⾯上，从⽽减少磁盘臂的移动次数。

## 24.5 磁盘碎⽚整理

移动⽂件使它们相邻，并把所有的空闲空间放在⼀个或多个⼤的连续区域内。












