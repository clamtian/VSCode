# 1. 前置++与后置++


## 为什么后置返回对象，而不是引用

## 为什么后置前面要加const

## 处理用户的自定义类型


# 2. a++ 和 int a = b 在C++中是否是线程安全的？

## a++

## int a = b

## 解决方法


# 3. C++类的三大特性

## 1. 继承

## 2. 封装

## 3. 多态


# 4. 虚函数

## 4.1 虚函数是动态绑定的


## 4.2 条件


## 4.3 构造函数不能是虚函数

## 4.4 虚函数的工作⽅式


## 4.5 析构函数可以是虚函数，⽽且，在⼀个复杂类结构中，这往往是必须的


## 4.6 虚函数必须实现么


## 4.7 子类必须要重写父类的虚函数么


## 4.8 inline, static, ~~constructor~~三种函数都不能带有virtual关键字


## 4.9 析构函数可以是纯虚的


## 4.10 派⽣类的override虚函数定义(返回值，函数名和形参)必须和⽗类完全⼀致


# 5. 虚继承

## 5.1 虚继承是为了解决多继承时的命名冲突和冗余数据问题


## 4.2 虚继承的目的是让某个类做出声明，承诺愿意共享它的基类


# 6. 抽象类与接口


# 7. 空类：为何空类的大小不是0？


# 8. 智能指针


## 8.1 shared_ptr


## 8.2 unique_ptr


## 8.3 weak_ptr


### weak_ptr的使用场景


# 9. C++强制类型转换


## 9.1 static_cast

## 9.2 dynamic_cast


## 9.3 const_cast


## 9.4 reinterpret_cast


# 10. 内存泄漏

## 10.1 什么是内存泄漏

## 10.2 内存泄漏分类
  
## 10.3 什么操作会导致内存泄露?

## 10.4 如何防⽌内存泄露?































