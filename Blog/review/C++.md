# 1. 前置++与后置++

```Javascript
// 前缀形式：增加然后取回值
UPInt& UPInt::operator++()
{
    *this += 1; // 增加
    return *this; // 取回值
}
// postfix form: fetch and increment
const UPInt UPInt::operator++(int)
{
    UPInt oldValue = *this; // 取回值
    ++(*this); // 增加
    return oldValue; // 返回被取回的值
}
```
重载函数间的区别决定于它们的参数类型上的差异，但是不论是increment或decrement的前缀还是后缀都只有一个参数。为了解决这个语言问题，C++规定后缀形式有一个int类型参数，当函数被调用时，编译器传递一个0做为int参数的值给该函数。

前缀形式返回一个引用，后缀形式返回一个const类型

## 为什么后置返回对象，⽽不是引⽤

因为后置为了返回旧值创建了⼀个临时对象，在函数结束的时候这个对象就会被销毁，函数不可以返回临时变量的引用！！！

## 为什么后置前⾯也要加const

为了防⽌你使⽤i++++,连续两次的调⽤后置++重载符。它与内置类型⾏为不⼀致：你⽆法取得你所期望的结果，因为第⼀次返回的是旧值，⽽不是原
对象，你调⽤两次后置++，结果只累加了⼀次，所以我们必须⼿动禁⽌其合法化，就要在前⾯加上const。

## 处理⽤户的⾃定义类型

最好使⽤前置++，因为他不会创建临时对象，进⽽不会带来构造和析构⽽造成的额外开销。


# 2. a++ 和 int a = b 在C++中是否是线程安全的？

不是

a++：从C/C++语法的级别来看，这是⼀条语句，应该是原⼦的；但从编译器得到的汇编指令来看，其实不是原⼦的。

```javascript
mov eax, dword ptr [a] # (1)
inc eax # (2)
mov dword ptr [a], eax # (3)
```

其⼀般对应三条指令，⾸先将变量a对应的内存值搬运到某个寄存器（如eax）中，然后将该寄存器中的值⾃增1，再将该寄存器中的值搬运回a代表的内存中

现在假设i的值是0，有两个线程，每个线程对变量a的值都递增1，预想⼀下，其结果应该是2，可实际运⾏结果可能是1！

分析：我们预想的结果是线程1和线程2的三条指令各⾃执⾏，最终a的值变为2，但是由于操作系统线程调度的不确定性，线程1执⾏完指令(1)和(2)后，eax寄存器中的值变为1，此时操作系统切换到线程2执⾏，执⾏指令(1)(2)(3)，此时eax的值变为1；接着操作系统切回线程1继续执⾏，执⾏指令(3)，得到a的最终结果1。

int a = b; 从C/C++语法的级别来看，这是条语句应该是原⼦的；但从编译器得到的汇编指令来看，由于现在计算机CPU架构体系的限制，**数据不能直接从内存某处搬运到内存另外⼀处，必须借助寄存器中转**，因此这条语句⼀般对应两条计算机指令，即将变量b的值搬运到某个寄存器（如eax）中，再从该寄存器搬运到变量a的内存地址中：

```javascript
mov eax, dword ptr [b]
mov dword prt [a], eax
```

既然是两条指令，那么多个线程在执⾏这两条指令时，某个线程可能会在第⼀条指令执⾏完毕后被剥夺CPU时间⽚，切换到另⼀个线程⽽出现不确定的情况。

## 解决方法

C++11新标准发布后改变了这种困境，新标准提供了对整形变量原⼦操作的相关库，即std::atomic，这是⼀个模板类型：

```javascript
template<class T>
struct atomic:
```

我们可以传⼊具体的整型类型对模板进⾏实例化，实际上stl库也提供了这些实例化的模板类型

```javascript
std::atomic<int> value;
value = 99;
```


# 3. c++类的三大特性

## 1.继承

让某种类型对象获得另⼀个类型对象的属性和⽅法，它可以使⽤现有类的所有功能，并在⽆需新编写原来的类的情况下对这些功能进⾏扩展

常⻅的继承有三种⽅式：
1、实现继承：指使⽤基类的属性和⽅法⽽⽆需额外编码的能⼒
2、接⼝继承：指仅使⽤属性和⽅法的名称、但是⼦类必须提供实现的能⼒
~~3、可视继承：指⼦窗体（类）使⽤基窗体（类）的外观和实现代码的能⼒~~

## 2.封装

数据和代码捆绑在⼀起，避免外界⼲扰和不确定性访问;

把客观事物封装成抽象的类，并且类可以把⾃⼰的数据和⽅法只让可信的类或者对象操作，对不可信的进⾏信息隐藏，例如：将公共的数据或⽅法使⽤public修饰，⽽不希望被访问的数据或⽅法采⽤private修饰。

## 3.多态

同⼀事物表现出不同事物的能⼒，即向不同对象发送同⼀消息，不同的对象在接收时会产⽣不同的⾏为（重载实现编译时多态，虚函数实现运⾏时多态）

关于多态，简而言之就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。

实现多态有两种⽅式
1. 覆盖（override）： 是指⼦类重新定义⽗类的虚函数的做法
2. 重载（overload）： 是指允许存在多个同名函数，⽽这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）


# 4. 虚函数

用来实现运行时动态绑定

```javascript
class A {
public:
	virtual void funcA();
	void funcB();
};
class B : public A {
public:
	virtual void funcA();
	void funcB();
};

void A::funcA () {
	cout << "A's funcA" << endl;
}
void A::funcB () {
	cout << "A's funcB" << endl;
}
void B::funcA () {
	cout << "B's funcA" << endl;
}
void B::funcB () {
	cout << "B's funcB" << endl;
}
 

int main(int argc,char* argv[])
{
	A *a = new B();
	a->funcA();          // run out : B's funcA
	a->funcB();          // run out : A's funcB
	return 1;
}
```

当基类希望派⽣类定义适合自己的版本，就将这些函数声明成虚函数（virtual）

虚函数依赖虚函数表工作，表来保存虚函数地址，当我们⽤基类指针指向派⽣类时，虚表指针指向派⽣类的虚函数表

这个机制可以保证派生类中的虚函数被调用到

1.虚函数是动态绑定的

也就是说，使⽤虚函数的指针和引⽤能够正确找到实际类的对应函数，⽽不是执⾏定义类的函数，发生在运行期。

2.条件

* 调⽤函数的对象必须是指针或者引⽤

* 被调⽤的函数必须是虚函数（virtual），且完成了虚函数的重写（派⽣类中有⼀个跟基类的完全相同虚函数）

3.构造函数不能是虚函数

⽽且，在构造函数中调用虚函数，实际执⾏的是⽗类的对应函数，因为自己还没有构造好, 多态是被disable的。

4.虚函数的工作⽅式

依赖虚函数表工作的，表来保存虚函数地址，当我们⽤基类指针指向派⽣类时，虚表指针vptr指向派⽣类的虚函数表，这个机制可以保证派⽣类中的虚函数被调⽤到。

5.析构函数可以是虚函数，⽽且，在⼀个复杂类结构中，这往往是必须的。

6.虚函数必须实现么

不是的，可以只提供声明而不做定义，这样这个虚函数称为纯虚函数。纯虚函数是通过在声明中使⽤ "= 0" 来指定的(virtual ReturnType Function()= 0)。包含纯虚函数的类称作虚类或者抽象类，不能定义对象

7.子类必须要重写父类的虚函数么

不是的，父类的虚函数只是希望子类重写自己的版本，如果没有重写，那么运行时调用的就是父类的函数。同时，子类的子类依旧可以选择重写这个虚函数

8.inline, static, ~~constructor~~三种函数都不能带有virtual关键字。

inline是在编译时展开，必须要有实体。内联函数是指在编译期间⽤被调⽤函数体本身来代替函数的调⽤指令，但虚函数的多态特性需要在运⾏时根据对象类型才知道调⽤哪个虚函数，所以没法在编译时进⾏内联函数展开。

static属于class⾃⼰的类相关，必须有实体；static成员没有this指针。virtual函数⼀定要通过对象来调⽤，有隐藏的this指针，实例相关。

9.析构函数可以是纯虚的

但纯虚析构函数必须有定义体，因为析构函数的调⽤是在⼦类中隐含的

10.派⽣类的override虚函数定义(返回值，函数名和形参)必须和⽗类完全⼀致。

除了⼀个特例，如果⽗类中返回值是⼀个指针或引⽤，⼦类override时可以返回这个指针（或引⽤）的派生。

# 5. 虚继承

```javascript
/*******************************多重继承****************************************/
class A { void func(){}; };
class B : public A {};
class C : public A {};
class D : public B , public C {};

D d;                 // A称作间接基类 构造函数调用流程为：A-B-A-C-D  A的构造函数会调用两次
!D.func();           // 错误 会出现歧义
D.B::func();         // 正确
D.C::func();         // 正确

/*******************************虚拟继承****************************************/
class A { void func(){}; };
class B : virtual public A {};
class C : virtual public A {};
class D : public B , public C {};

D d;                 // 构造函数调用流程为：A-B-C-D      A的构造函数会调用一次
D.func();           // 正确
D.B::func();         // 正确
D.C::func();         // 正确
```

1、虚继承是为了解决多继承时的命名冲突和冗余数据问题

C++ 提出了虚继承，使得在派⽣类中只保留⼀份间接基类的成员。其中多继承（Multiple
Inheritance）是指一个派生类继承了多个直接基类，多继承的派⽣类继承了所有⽗类的成员。

2、虚继承的⽬的是让某个类做出声明，承诺愿意共享它的基类

其中，这个被共享的基类就称为虚基类（Virtual Base Class），其中上面代码中A就是⼀个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派⽣类中都只包含⼀份虚基类的成员。

类 A 有⼀个成员变量a，不使⽤虚继承，那么在类 D 中直接访问 a 就会产⽣歧义。编译器不知道它究竟来⾃ A-->B-->D 这条路径，还是来⾃ A-->C-->D 这条路径。

C++标准库中的 iostream 类就是⼀个虚继承的实际应⽤案例。iostream 从 istream 和 ostream 直接继承⽽来，⽽ istream 和 ostream ⼜都继承⾃⼀个共同的名为 baseios 的类。此时 istream 和 ostream 必须采⽤虚继承，否则将导致 iostream 类中保留两份 baseios 类的成员。

使⽤多继承经常出现二义性，必须⼗分⼩⼼；⼀般只有在比较简单和不易出现二义性或者在必要情况下才使⽤多继承，能⽤单⼀继承解决问题就不要⽤多继承。

# 6. 抽象类与接⼝

接口描述了类的⾏为和功能，⽽不需要完成类的特定实现；C++ 接⼝是使⽤抽象类来实现的

1、类中⾄少有⼀个函数被声明为纯虚函数，则这个类就是抽象类。

2、如果一个类里面只有纯虚函数，没有其他成员函数和数据成员，就是接口类。

2、接口属于抽象类，设计抽象类的⽬的，是为了给其他类提供⼀个可以继承的适当的基类。抽象类不能被⽤于实例化对象。

# 7. 空类

为何空类的⼤⼩不是0？

为了确保两个不同对象的地址不同。

类的实例化是在内存中分配⼀块地址，每个实例在内存中都有独一无二的地址。同样，空类也会实例化，所以编译器会给空类隐含的添加⼀个字节，这样空类实例化后就有独一无二的地址了。

所以，空类的sizeof为1，⽽不是0。

```javascript
 // 类A和类B都不是空类，其sizeof都是4，因为它们都具有虚函数表的地址。
class A{ virtual void f(){} };
class B:public A{};     

// A是空类，其⼤⼩为1；B不是空类，其⼤⼩为4.因为含有指向虚基类的指针
class A{};
class B:public virtual A{};

// 多重继承的空类的⼤⼩也是1。下面三个类的sizeof都是1
class Father1{}; class Father2{};
class Child:Father1, Father2{};

// 多重继承的其他例子
class X{}; //sizeof(X):1
class Y : public virtual X {}; //sizeof(Y):4
class Z : public virtual X {}; //sizeof(Z):4
class A : public virtual Y {}; //sizeof(A):8
class B : public Y, public Z{}; //sizeof(B):8
class C : public virtual Y, public virtual Z {}; //sizeof(C):12
class D : public virtual C{}; //sizeof(D):16
```

# 8.智能指针

对象需要严格的生存期，全局对象在程序启动时分配，在程序结束时销毁。对于局部自动对象，当我们进入其定义所在的程序块时被创建，在离开块时销毁。C++还支持动态分配对象，动态分配的对象的生存期与它们在哪里创建是无关的，只有当显示地被释放时，这些对象才会被销毁。

动态对象的正确释放被证明是编程中极易容易出错的地方。为了更安全的使用动态对象，标准库定义了两个智能指针类型来管理动态分配的对象。当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它。

## 1.shared_ptr

shared_ptr的实现机制是在拷贝构造时使⽤同⼀份引⽤计数

* 重载operator*和operator->，使得能像指针⼀样使⽤shared_ptr

* 重载copy constructor，使其引⽤次数加⼀（拷贝构造函数)
  
* 重载operator=（赋值运算符），如果原来的shared_ptr已经有对象，则让其引⽤次数减⼀并判断引⽤是否为零(是否调⽤delete)，然后将新的对象引⽤次数加一

* 重载析构函数，使引⽤次数减⼀并判断引⽤是否为零(是否调⽤delete)

* make_shared函数在动态内存中分配一个对象并初始化，返回指向此对象的shared_ptr。

智能指针包括一个实际数据指针和一个引用计数指针，这两个操作不是一个指令可以完成的，因此多线程环境下，势必有问题。

* 同一个shared_ptr被多个线程读，是线程安全的；
* 同一个shared_ptr被多个线程写，不是线程安全的；
* 共享引用计数的不同的shared_ptr被多个线程写，是线程安全的。

## 2.unique_ptr

* unique_ptr”唯⼀”拥有其所指对象,同⼀时刻只能有⼀个unique_ptr指向给定对象，离开作⽤域时，若其指向对象，则将其所指对象销毁（默认delete）。

* 与shared_ptr不同，没有类似make_shared的标准库函数返回一个unique_ptr,定义unique_ptr时,需要将其绑定到⼀个new返回的指针上。

* unique_ptr不⽀持普通的拷⻉和赋值（因为拥有指向的对象）,但是可以拷⻉和赋值⼀个将要被销毁的unique_ptr；可以通过release或者reset将指针所有权从⼀个（⾮const）unique_ptr转移到另⼀个unique。

## 3.weak_ptr

* weak_ptr是为了配合shared_ptr⽽引⼊的⼀种智能指针,它的最⼤作⽤在于协助shared_ptr⼯作，像旁观者那样观测资源的使⽤情况，但weak_ptr没有共享资源，它的构造不会引起指针引⽤计数的增加。

* 和shared_ptr指向相同内存，由于对象可能不存在，不能直接使用weak_ptr直接访问对象，而必须使用lock，此函数检查weak_ptr指向的对象是否存在，存在则返回一个指向对象的shared_ptr。

例子：比方说想知道某个vector是否存在，直接访问这个vector可能会发生错误，这时候可以利用weak_ptr来检查vector是否存在

































