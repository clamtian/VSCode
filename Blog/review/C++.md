# 1. 前置++与后置++

```Javascript
// 前缀形式：增加然后取回值
UPInt& UPInt::operator++()
{
    *this += 1; // 增加
    return *this; // 取回值
}
// postfix form: fetch and increment
const UPInt UPInt::operator++(int)
{
    UPInt oldValue = *this; // 取回值
    ++(*this); // 增加
    return oldValue; // 返回被取回的值
}
```
重载函数间的区别决定于它们的参数类型上的差异，但是不论是increment或decrement的前缀还是后缀都只有一个参数。为了解决这个语言问题，C++规定后缀形式有一个int类型参数，当函数被调用时，编译器传递一个0做为int参数的值给该函数。

前缀形式返回一个引用，后缀形式返回一个const类型

## 为什么后置返回对象，⽽不是引⽤

因为后置为了返回旧值创建了⼀个临时对象，在函数结束的时候这个对象就会被销毁，函数不可以返回临时变量的引用！！！

## 为什么后置前⾯也要加const

为了防⽌你使⽤i++++,连续两次的调⽤后置++重载符。它与内置类型⾏为不⼀致：你⽆法取得你所期望的结果，因为第⼀次返回的是旧值，⽽不是原
对象，你调⽤两次后置++，结果只累加了⼀次，所以我们必须⼿动禁⽌其合法化，就要在前⾯加上const。

## 处理⽤户的⾃定义类型

最好使⽤前置++，因为他不会创建临时对象，进⽽不会带来构造和析构⽽造成的额外开销。


# 2. a++ 和 int a = b 在C++中是否是线程安全的？

不是

a++：从C/C++语法的级别来看，这是⼀条语句，应该是原⼦的；但从编译器得到的汇编指令来看，其实不是原⼦的。

```javascript
mov eax, dword ptr [a] # (1)
inc eax # (2)
mov dword ptr [a], eax # (3)
```

其⼀般对应三条指令，⾸先将变量a对应的内存值搬运到某个寄存器（如eax）中，然后将该寄存器中的值⾃增1，再将该寄存器中的值搬运回a代表的内存中

现在假设i的值是0，有两个线程，每个线程对变量a的值都递增1，预想⼀下，其结果应该是2，可实际运⾏结果可能是1！

分析：我们预想的结果是线程1和线程2的三条指令各⾃执⾏，最终a的值变为2，但是由于操作系统线程调度的不确定性，线程1执⾏完指令(1)和(2)后，eax寄存器中的值变为1，此时操作系统切换到线程2执⾏，执⾏指令(1)(2)(3)，此时eax的值变为1；接着操作系统切回线程1继续执⾏，执⾏指令(3)，得到a的最终结果1。

int a = b; 从C/C++语法的级别来看，这是条语句应该是原⼦的；但从编译器得到的汇编指令来看，由于现在计算机CPU架构体系的限制，**数据不能直接从内存某处搬运到内存另外⼀处，必须借助寄存器中转**，因此这条语句⼀般对应两条计算机指令，即将变量b的值搬运到某个寄存器（如eax）中，再从该寄存器搬运到变量a的内存地址中：

```javascript
mov eax, dword ptr [b]
mov dword prt [a], eax
```

既然是两条指令，那么多个线程在执⾏这两条指令时，某个线程可能会在第⼀条指令执⾏完毕后被剥夺CPU时间⽚，切换到另⼀个线程⽽出现不确定的情况。

## 解决方法

C++11新标准发布后改变了这种困境，新标准提供了对整形变量原⼦操作的相关库，即std::atomic，这是⼀个模板类型：

```javascript
template<class T>
struct atomic:
```

我们可以传⼊具体的整型类型对模板进⾏实例化，实际上stl库也提供了这些实例化的模板类型

```javascript
std::atomic<int> value;
value = 99;
```


# 3. c++类的三大特性

## 1.继承

让某种类型对象获得另⼀个类型对象的属性和⽅法，它可以使⽤现有类的所有功能，并在⽆需新编写原来的类的情况下对这些功能进⾏扩展

常⻅的继承有三种⽅式：
1、实现继承：指使⽤基类的属性和⽅法⽽⽆需额外编码的能⼒
2、接⼝继承：指仅使⽤属性和⽅法的名称、但是⼦类必须提供实现的能⼒
~~3、可视继承：指⼦窗体（类）使⽤基窗体（类）的外观和实现代码的能⼒~~

## 2.封装

数据和代码捆绑在⼀起，避免外界⼲扰和不确定性访问;

把客观事物封装成抽象的类，并且类可以把⾃⼰的数据和⽅法只让可信的类或者对象操作，对不可信的进⾏信息隐藏，例如：将公共的数据或⽅法使⽤public修饰，⽽不希望被访问的数据或⽅法采⽤private修饰。

## 3.多态

同⼀事物表现出不同事物的能⼒，即向不同对象发送同⼀消息，不同的对象在接收时会产⽣不同的⾏为（重载实现编译时多态，虚函数实现运⾏时多态）

关于多态，简而言之就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。

实现多态有两种⽅式
1. 覆盖（override）： 是指⼦类重新定义⽗类的虚函数的做法
2. 重载（overload）： 是指允许存在多个同名函数，⽽这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）


# 4. 虚函数

用来实现运行时动态绑定

```javascript
class A {
public:
	virtual void funcA();
	void funcB();
};
class B : public A {
public:
	virtual void funcA();
	void funcB();
};

void A::funcA () {
	cout << "A's funcA" << endl;
}
void A::funcB () {
	cout << "A's funcB" << endl;
}
void B::funcA () {
	cout << "B's funcA" << endl;
}
void B::funcB () {
	cout << "B's funcB" << endl;
}
 

int main(int argc,char* argv[])
{
	A *a = new B();
	a->funcA();          // run out : B's funcA
	a->funcB();          // run out : A's funcB
	return 1;
}
```

当基类希望派⽣类定义适合自己的版本，就将这些函数声明成虚函数（virtual）

虚函数依赖虚函数表工作，表来保存虚函数地址，当我们⽤基类指针指向派⽣类时，虚表指针指向派⽣类的虚函数表

这个机制可以保证派生类中的虚函数被调用到

1.虚函数是动态绑定的

也就是说，使⽤虚函数的指针和引⽤能够正确找到实际类的对应函数，⽽不是执⾏定义类的函数，发生在运行期。

2.条件

* 调⽤函数的对象必须是指针或者引⽤

* 被调⽤的函数必须是虚函数（virtual），且完成了虚函数的重写（派⽣类中有⼀个跟基类的完全相同虚函数）

3.构造函数不能是虚函数

⽽且，在构造函数中调用虚函数，实际执⾏的是⽗类的对应函数，因为自己还没有构造好, 多态是被disable的。

4.虚函数的工作⽅式

依赖虚函数表工作的，表来保存虚函数地址，当我们⽤基类指针指向派⽣类时，虚表指针vptr指向派⽣类的虚函数表，这个机制可以保证派⽣类中的虚函数被调⽤到。

5.析构函数可以是虚函数，⽽且，在⼀个复杂类结构中，这往往是必须的。

6.将一个函数定义为纯虚函数。

实际上是将这个类定义为抽象类，不能实例化对象；纯虚函数通常没有定义体，但也完全可以拥有。

7.子类必须要重写父类的虚函数么

不是的，父类的虚函数只是希望子类重写自己的版本，如果没有重写，那么运行时调用的就是父类的函数。同时，子类的子类依旧可以选择重写这个虚函数

8.inline, static, ~~constructor~~三种函数都不能带有virtual关键字。

inline是在编译时展开，必须要有实体。内联函数是指在编译期间⽤被调⽤函数体本身来代替函数的调⽤指令，但虚函数的多态特性需要在运⾏时根据对象类型才知道调⽤哪个虚函数，所以没法在编译时进⾏内联函数展开。

static属于class⾃⼰的类相关，必须有实体；static成员没有this指针。virtual函数⼀定要通过对象来调⽤，有隐藏的this指针，实例相关。

9.虚函数必须实现么

不是的，可以只提供声明而不做定义，这样这个虚函数称为纯虚函数。包含纯虚函数的类称作虚类或者抽象类，不能定义对象

10.析构函数可以是纯虚的

但纯虚析构函数必须有定义体，因为析构函数的调⽤是在⼦类中隐含的

11.派⽣类的override虚函数定义(返回值，函数名和形参)必须和⽗类完全⼀致。

除了⼀个特例，如果⽗类中返回值是⼀个指针或引⽤，⼦类override时可以返回这个指针（或引⽤）的派生。

# 5. 虚继承

```javascript
/*******************************多重继承****************************************/
class A { void func(){}; };
class B : public A {};
class C : public A {};
class D : public B , public C {};

D d;                 // 构造函数调用流程为：A-B-A-C-D      A的构造函数会调用两次
!D.func();           // 错误 会出现歧义
D.B::func();         // 正确
D.C::func();         // 正确

/*******************************虚拟继承****************************************/
class A { void func(){}; };
class B : virtual public A {};
class C : virtual public A {};
class D : public B , public C {};

D d;                 // 构造函数调用流程为：A-B-C-D      A的构造函数会调用一次
D.func();           // 正确
D.B::func();         // 正确
D.C::func();         // 正确
```

1、虚继承是为了解决多继承时的命名冲突和冗余数据问题
C++ 提出了虚继承，使得在派⽣类中只保留⼀份间接基类的成员。其中多继承（Multiple
Inheritance）是指从多个直接基类中产⽣派⽣类的能⼒，多继承的派⽣类继承了所有⽗类的成
员。




















